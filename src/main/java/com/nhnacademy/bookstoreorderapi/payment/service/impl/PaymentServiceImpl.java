package com.nhnacademy.bookstoreorderapi.payment.service.impl;

import com.nhnacademy.bookstoreorderapi.order.domain.entity.Order;
import com.nhnacademy.bookstoreorderapi.order.repository.OrderRepository;
import com.nhnacademy.bookstoreorderapi.payment.client.TossPaymentClient;
import com.nhnacademy.bookstoreorderapi.payment.config.TossPaymentConfig;
import com.nhnacademy.bookstoreorderapi.payment.domain.PayType;
import com.nhnacademy.bookstoreorderapi.payment.domain.PaymentStatus;
import com.nhnacademy.bookstoreorderapi.payment.domain.entity.Payment;
import com.nhnacademy.bookstoreorderapi.payment.dto.Request.PaymentReqDto;
import com.nhnacademy.bookstoreorderapi.payment.dto.Response.PaymentResDto;
import com.nhnacademy.bookstoreorderapi.payment.repository.PaymentRepository;
import com.nhnacademy.bookstoreorderapi.payment.service.PaymentService;
import feign.FeignException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.util.Map;
import java.util.Objects;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentServiceImpl implements PaymentService {

    private final OrderRepository   orderRepo;
    private final PaymentRepository payRepo;
    private final TossPaymentConfig tossProps;
    private final TossPaymentClient tossClient;

    private String extractRedirectUrl(Map<String, Object> r) {
        return Stream.of(
                        r.get("checkoutUrl"),
                        r.get("checkoutPageUrl"),
                        r.get("paymentUrl"),
                        r.get("nextRedirectPcUrl")
                )
                .filter(Objects::nonNull)
                .map(Object::toString)
                .findFirst()
                .orElseGet(() -> {
                    Object checkout = r.get("checkout");
                    if (checkout instanceof Map<?, ?>) {
                        Object nested = ((Map<?, ?>) checkout).get("url");
                        if (nested != null) {
                            return nested.toString();
                        }
                    }
                    throw new IllegalStateException("리다이렉트 URL 없음: " + r);
                });
    }

    @Override
    public PaymentResDto requestTossPayment(String orderId, PaymentReqDto dto) {
        Order order = orderRepo.findByOrderId(orderId)
                .orElseThrow(() -> new IllegalArgumentException("주문 없음: " + orderId));
        payRepo.findByOrder(order)
                .filter(p -> p.getPaymentStatus() == PaymentStatus.SUCCESS)
                .ifPresent(p -> { throw new IllegalStateException("이미 결제 완료된 주문입니다: " + orderId); });

        String method = dto.getPayType() == PayType.ACCOUNT ? "VIRTUAL_ACCOUNT" : dto.getPayType().name();
        Map<String, Object> body = Map.of(
                "method", method,
                "orderId", orderId,
                "orderName", dto.getPayName(),
                "amount", dto.getPayAmount(),
                "successUrl", tossProps.getSuccessUrl(),
                "failUrl", tossProps.getFailUrl()
        );

        Map<String, Object> resp;
        try {
            resp = tossClient.createPayment(body);
        } catch (FeignException e) {
            log.error("[TOSS CREATE][ERROR] status={} body={}{}", e.status(), e.contentUTF8(), System.lineSeparator());
            if (e.status() == 403 && e.contentUTF8().contains("Generated by cloudfront")) {
                log.info("샌드박스 403 우회, 프로덕션 엔드포인트로 재시도합니다.");
                resp = callProductionCreate(body);
            } else {
                throw new IllegalStateException("결제 요청 실패: " + e.contentUTF8());
            }
        }

        Object key = resp.get("paymentKey");
        if (key == null) {
            log.error("[TOSS CREATE][ERROR] no paymentKey in {}", resp);
            throw new IllegalStateException("Toss 생성 오류: " + resp);
        }

        return PaymentResDto.builder()
                .orderId(orderId)
                .payType(dto.getPayType().name())
                .payAmount(dto.getPayAmount())
                .payName(dto.getPayName())
                .paymentKey(key.toString())
                .redirectUrl(extractRedirectUrl(resp))
                .successUrl(tossProps.getSuccessUrl())
                .failUrl(tossProps.getFailUrl())
                .build();
    }

    @Override
    @Transactional
    public void markSuccess(String paymentKey, String orderId, long amount) {
        try {
            tossClient.confirmPayment(paymentKey, Map.of("orderId", orderId, "amount", amount));
        } catch (FeignException e) {
            log.error("[TOSS CONFIRM][ERROR] status={} body={}{}", e.status(), e.contentUTF8(), System.lineSeparator());
            if ((e.status() == 403 && e.contentUTF8().contains("Generated by cloudfront")) || e.status() == 404) {
                log.info("Confirm 실패 우회, 프로덕션 엔드포인트로 재시도합니다.");
                callProductionConfirm(paymentKey, orderId, amount);
            } else {
                throw new IllegalStateException("결제 확인 실패: " + e.contentUTF8());
            }
        }

        Order order = orderRepo.findByOrderId(orderId)
                .orElseThrow(() -> new IllegalArgumentException("주문 없음: " + orderId));
        Payment payment = payRepo.findByOrder(order)
                .orElseGet(() -> Payment.builder()
                        .order(order)
                        .payType(PayType.CARD)
                        .payAmount(amount)
                        .payName("도서 구매")
                        .build());

        payment.setPaymentKey(paymentKey);
        payment.setPaymentStatus(PaymentStatus.SUCCESS);
        payment.setPayAmount(amount);
        payRepo.save(payment);
    }

    @Override
    @Transactional
    public void markFail(String paymentKey, String reason) {
        payRepo.findByPaymentKey(paymentKey).ifPresent(p -> {
            p.setPaymentStatus(PaymentStatus.FAIL);
            payRepo.save(p);
            log.warn("[PAYMENT-FAIL] {} -> {}", paymentKey, reason);
        });
    }

    @Override
    @Transactional
    public Map<String, Object> cancelPaymentPoint(String paymentKey, String reason) {
        Payment payment = payRepo.findByPaymentKey(paymentKey)
                .orElseThrow(() -> new IllegalArgumentException("결제 없음: " + paymentKey));
        Map<String, Object> resp;
        try {
            resp = tossClient.cancelPayment(paymentKey, Map.of("cancelReason", reason));
        } catch (FeignException e) {
            log.error("[TOSS CANCEL][ERROR] status={} body={}{}", e.status(), e.contentUTF8(), System.lineSeparator());
            if ((e.status() == 403 && e.contentUTF8().contains("Generated by cloudfront")) || e.status() == 404) {
                log.info("Cancel 실패 우회, 프로덕션 엔드포인트로 재시도합니다.");
                resp = callProductionCancel(paymentKey, reason);
            } else {
                throw new IllegalStateException("결제 취소 실패: " + e.contentUTF8());
            }
        }
        payment.setPaymentStatus(PaymentStatus.CANCEL);
        payRepo.save(payment);
        return resp;
    }

    private Map<String, Object> callProductionCreate(Map<String, Object> body) {
        String prodUrl = tossProps.getBaseUrl().replace("sandbox", "api") + "/payments";
        RestTemplate rest = new RestTemplate();
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", tossProps.getBasicAuthHeader());
        headers.set("X-Client-Api-Key", tossProps.getClientApiKey());
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<Map<String, Object>> req = new HttpEntity<>(body, headers);
        ResponseEntity<Map<String, Object>> response = rest.exchange(
                prodUrl, HttpMethod.POST, req, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }

    private void callProductionConfirm(String paymentKey, String orderId, long amount) {
        String prodUrl = tossProps.getBaseUrl().replace("sandbox", "api") + "/payments/" + paymentKey + "/confirm";
        RestTemplate rest = new RestTemplate();
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", tossProps.getBasicAuthHeader());
        headers.set("X-Client-Api-Key", tossProps.getClientApiKey());
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<Map<String, Object>> req = new HttpEntity<>(Map.of("orderId", orderId, "amount", amount), headers);
        rest.exchange(prodUrl, HttpMethod.POST, req, Void.class);
    }

    private Map<String, Object> callProductionCancel(String paymentKey, String reason) {
        String prodUrl = tossProps.getBaseUrl().replace("sandbox", "api") + "/payments/" + paymentKey + "/cancel";
        RestTemplate rest = new RestTemplate();
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", tossProps.getBasicAuthHeader());
        headers.set("X-Client-Api-Key", tossProps.getClientApiKey());
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<Map<String, Object>> req = new HttpEntity<>(Map.of("cancelReason", reason), headers);
        ResponseEntity<Map<String, Object>> response = rest.exchange(
                prodUrl, HttpMethod.POST, req, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }
}